---
layout: post
title:  "es6-一、let和const命令"
date:   2016-12-2 11:49:45 +0200
categories: jekyll es6
---
ES6一共有6种声明变量的方法:var命令和function命令:ES5+let和const命令+import命令和class命令:ES5只有两种声明变量的方法：var命令和function命令。
ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。
所以，ES6一共有6种声明变量的方法。

1、let命令：它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。
{% highlight ruby %}
{
  let a = 10;
  var b = 1;
}
#=> a // ReferenceError: a is not defined.
#=> b // 1
{% endhighlight %}

1.1:let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。
{% highlight ruby %}
console.log(foo); // 输出undefined
console.log(bar); // 报错ReferenceError

var foo = 2;
let bar = 2;
{% endhighlight %}
1.2：只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
{% highlight ruby %}
var tmp = 123;

if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
{% endhighlight %}
1.2.1: 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。
{% highlight ruby %}
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
{% endhighlight %}
1.3:“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。
{% highlight ruby %}
typeof x; // ReferenceError
let x;
{% endhighlight %}
1.4:let不允许在相同作用域内，重复声明同一个变量。:let不允许在相同作用域内，重复声明同一个变量。
{% highlight ruby %}
function func(arg) {
  let arg; // 报错
}
// 报错
function () {
  let a = 10;
  var a = 1;
}
function func(arg) {
  {
    let arg; // 不报错
  }
}
{% endhighlight %}
1.5：块级作用域    

1、下面代码中，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。
    {% highlight ruby %}
    var tmp = new Date();
    function f() {
      console.log(tmp);
      if (false) {
        var tmp = "hello world";
      }
    }

    f(); // undefined
    {let insane='hello';{let insane="hello word"}; console.log(insane)} 
    #=>//hello
    {% endhighlight %}

2、用来计数的循环变量泄露为全局变量。下面代码，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。
    {% highlight ruby %}
    var s = 'hello';

    for (var i = 0; i < s.length; i++) {
      console.log(s[i]);
    }
    {% endhighlight %}    

3、外层作用域无法读取内层作用域的变量，内层作用域可以定义外层作用域的同名变量。
    {% highlight ruby %}
    {
      {let insane = 'Hello World'}
      console.log(insane); // 报错
    };
    {
      let insane = 'Hello World';
      {console.log(insane)}
    };
    {
      let insane = 'Hello World';
      {let insane = 'hi'}
    };
    {% endhighlight %}  
4、ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
{% highlight ruby %}
    function f() { console.log('I am outside!'); }
    (function () {
      if (false) {
        // 重复声明一次函数f
        function f() { console.log('I am inside!'); }
      }

      f();
    }());
{% endhighlight %}  
上面这段代码在chrome下会报错    
考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。  
{% highlight ruby %}   
    // 函数声明语句
    {
      let a = 'secret';
      function f() {
        return a;
      }
    }

    // 函数表达式
    {
      let a = 'secret';
      let f = function () {
        return a;
      };
    }
    ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。
    // 不报错
    'use strict';
    if (true) {
      function f() {}
    }

    // 报错
    'use strict';
    if (true)
      function f() {}
{% endhighlight %} 
2、const声明一个只读的常量。一旦声明，常量的值就不能改变。    
   2.1、const的作用域与let命令相同：只在声明所在的块级作用域内有效。     
   2.2、const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。     
   2.3、const声明的常量，也与let一样不可重复声明。     
   2.4、对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变   
   {% highlight ruby %}   
        const foo = {};
        foo.prop = 123;
        foo.prop
        // 123

        foo = {}; // TypeError: "foo" is read-only

        const a = [];
        a.push('Hello'); // 可执行
        a.length = 0;    // 可执行
        a = ['Dave'];    // 报错

        2.4.1：如果真的想将对象冻结，应该使用Object.freeze方法。
        const foo = Object.freeze({});
        // 常规模式时，下面一行不起作用；
        // 严格模式时，该行会报错
        foo.prop = 123;
        除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。
        var constantize = (obj) => {
          Object.freeze(obj);
          Object.keys(obj).forEach( (key, value) => {
            if ( typeof obj[key] === 'object' ) {
              constantize( obj[key] );
            }
          });
        };
    {% endhighlight %} 
3、顶层对象      
    3.1：顶层对象的属性        
         在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。     
         {% highlight ruby %}        
         window.a = 1;
         a // 1
         a = 2;
         window.a // 2
         {% endhighlight %} 
ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。
         {% highlight ruby %} 
         var a = 1;
            // 如果在Node的REPL环境，可以写成global.a
            // 或者采用通用方法，写成this.a
            window.a // 1

            let b = 1;
            window.b // undefined
        {% endhighlight %} 
{% highlight ruby %} 
<script type="text/javascript">
    {
      let a = 10;
      var b = 1;
    }
   // console.log("a:"+a);
    console.log("b:"+b)
    var a=[]
    for(let i = 0;i<10;i++){
        a[i] = function(){
            console.log(i);
        }
    }
    a[6]();
</script>
</body>
</html>
{% endhighlight %} 
**本文取自**：<http://es6.ruanyifeng.com/>   

**博客demo地址**： [Jekyll docs][jekyll-docs] for more info on how to get the most out of Jekyll. File all bugs/feature requests at [Jekyll’s GitHub repo][jekyll-gh]. If you have questions, you can ask them on [Jekyll Talk][jekyll-talk].

[jekyll-docs]: http://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/

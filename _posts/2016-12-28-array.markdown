---
layout: post
title:  "es6-六、数组的扩展"
date: 2016-12-28 9:00:00 +0800
categories: jekyll es6
---
#### 1、Array.from()   
Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）     
//对于没有部署该方法的浏览器可以用Array.prototype.slice方法替换     
const toArray = (()=> Array.from? Array.from : obj => [].slice.call(obj))();
通过eval() 函数可以将JSON字符串转化为对象：var dataObj=eval("("+data+")");//转换为json对象       
JSON.parse(myJSONtext, filter);  jQuery.parseJSON()   
{% highlight ruby %}  
var value = 1;
var jsonstr = '{"data1":"hello","data2":++value}';
var data1 = eval_r('('+jsonstr+')');
console.log(data1);//这时value值为2
var data2=JSON.parse(jsonstr);
console.log(data2);//报错  
{% endhighlight %}
#=>eval和parse的区别：eval在解析字符串时，会执行该字符串中的代码（这样的后果是相当恶劣的）   
#=> jQuery.parseJSON()函数用于将格式完好的JSON字符串转为与之对应的JavaScript对象。所谓"格式完好"，就是要求指定的字符串必须符合严格的JSON格式，例如：属性名称必须加双引号、字符串值也必须用双引号。   
JSON.stringify(obj);用来将一个js对象转换为 JSON 文本。  
   
{% highlight ruby %}  
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};
//Es5的写法 
var arr1=[].slice.call(arraylike); //[a,b,c]
// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
Array.from方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。   
Array.from({ length: 3 });  // [ undefined, undefined, undefined ]
{% endhighlight %}
常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。  
querySelectorAll方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用forEach方法。    
{% highlight ruby %}  
// NodeList对象
let ps = document.querySelectorAll('p');
Array.from(ps).forEach(function (p) {
  console.log(p);
});
// arguments对象
function foo() {
  var args = Array.from(arguments);
  // ...
}
//字符串和Set结构都具有Iterator接口，因此可以被Array.from转为真正的数组。
Array.from('hello')
// ['h', 'e', 'l', 'l', 'o']
let namesSet = new Set(['a', 'b'])
Array.from(namesSet) // ['a', 'b']
Array.from([1, 2, 3])
// [1, 2, 3]
// arguments对象
function foo() {var args = [...arguments];}
// NodeList对象
[...document.querySelectorAll('div')]
//扩展运算符（...）也可以将某些数据结构转为数组。
{% endhighlight %}
Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。   
{% highlight ruby %}   
Array.from(arrayLike, x => x * x);
// 等同于
Array.from(arrayLike).map(x => x * x);
Array.from([1, 2, 3], (x) => x * x)
// [1, 4, 9]
Array.from接收第二个参数，作用和map方法类似用于对每个元素进行处理; 
Array.from(arrayLike, x => x * x);
Array.frome(arrayLike).map(x => x*x);
下面的例子是取出一组DOM节点的文本内容。
let spans=document.querySelectorAll('span.name');
let name1 = Array.prototype.map.call(spans, s=>s.textContent);
let name2 = Array.from(spans, s=>s.textContent);
Array.prototype.map.call(a,x=>x*x);
Array.from([1, , 2, , 3], (n) => n || 0)  // [1, 0, 2, 0, 3]
返回各种数据的类型: function typeof(){ return Array.from(arguments, value => typeof value)}
typeof(null,[],NaN) //['object','object','number']
{% endhighlight %} 
#### 2、Array.of()
数组构造函数Array()的不足，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。      
Array.of基本上可以用来替代Array()或new Array()  
{% highlight ruby %}
Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
Array.of可以用下面代码模拟实现:     
function Arrayof(){ return [].slice.call(arguments);}
{% endhighlight %}
#### 3、copyWithin  
target（必需）：从该位置开始替换数据。
start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。
end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数         
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)//将3号位复制到0号位   [4, 2, 3, 4, 5]       
[1, 2, 3, 4, 5].copyWithin(0, -2, -1) //  -2相当于3号位，-1相当于4号位  [4, 2, 3, 4, 5]   
???[].copyWithin.call({length: 5, 3: 1}, 0, 3)// 将3号位复制到0号位  {0: 1, 3: 1, length: 5}
#### 4、数组find()和findIndex()
{% highlight ruby %}
[1, 5, 10, 15].find(function(value, index, arr) {
  return value > 9;
}) // 10
上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。
{% endhighlight %} 
find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员 。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足:[NaN].findIndex(y => Object.is(NaN, y))     
{% highlight ruby %}
#=>Object.is是es6   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is 
if (!Object.is) {
  Object.is = function(x, y) {
    // SameValue algorithm
    if (x === y) { // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  };
}if (!Object.is) {
  Object.is = function(x, y) {
    // SameValue algorithm
    if (x === y) { // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  };
} 
{% endhighlight %} 
#### 5、数组实例的fill()   
fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。
fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。
{% highlight ruby %}   
['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c']
['a', 'b', 'c'].fill(7)
// [7, 7, 7]
new Array(3).fill(7)
// [7, 7, 7]  
{% endhighlight %}  
#### 6、ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组   
   {% highlight ruby %} 
   for (let index of ['a','b'].keys()){
       console.log(index);
   }//0  //1  
   for (let elem of ['a','b'].values()){
       console.log(elem);
   }//a  //b  
   for (let [index elem] of ['a','b'].entries()){
       console.log(index,elem);
   }//0"a"  //1"b" 
   {% endhighlight %} 
   不用for...of循环，可以手动调用遍历器对象next方法，进行遍历。
   {% highlight ruby %} 
    let letter = ['a', 'b', 'c'];
    let entries = letter.entries();
    console.log(entries.next().value); // [0, 'a']
    console.log(entries.next().value); // [1, 'b']
    console.log(entries.next().value); // [2, 'c']
   {% endhighlight %}
#### 7、includes   Es7
[NaN, "bar"].includes(NaN)
在这之前我们通常使用indexof()，检查是否包含某值 
{% highlight ruby %}   
const contains = (() =>
  Array.prototype.includes
    ? (arr, value) => arr.includes(value)
    : (arr, value) => arr.some(el => el === value)
)();
contains(["foo", "bar"], "baz"); // => false
{% endhighlight %}
Map结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。      
Set结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。     
#### 8、数组的空位   
forEach(), filter(), every() 和some()都会跳过空位。    
map()会跳过空位，但会保留这个值    
join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。  
ES6则是明确将空位转为undefined 。 如 Array.from  扩展运算符（...）  copyWithin()  fill()  for...of循环也会遍历空位。

**博客demo地址**： [Jekyll docs][jekyll-docs] for more info on how to get the most out of Jekyll. File all bugs/feature requests at [Jekyll’s GitHub repo][jekyll-gh]. If you have questions, you can ask them on [Jekyll Talk][jekyll-talk].

[jekyll-docs]: http://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/


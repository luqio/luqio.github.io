---
layout: post
title:  "es6-七、函数的扩展"
date: 2016-12-28 9:00:00 +0800
categories: jekyll es6
---
#### 1、参数设置默认值    
{% highlight ruby %}
function log(x, y = 'World') {
  console.log(x, y);
}
参数变量是默认声明的，所以不能用let或const再次声明。   
function foo(x = 5) {
  let x = 1; // error
  const x = 2; // err
  }
{% endhighlight %}
如果非尾部的参数设置默认值，实际上这个参数是没法省。   
如果传入undefined，将触发该参数等于默认值，null则没有这个效果。   
{% highlight ruby %}
function f(x = 1, y) {
  return [x, y];
}
f(, 1) // 报错
f(undefined, 1) // [1, 1]
// 例二
function f(x, y = 5, z) {
  return [x, y, z];
}f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]
{% endhighlight %}
#### 2、与解构赋值默认值结合使用   
只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值而生成  
{% highlight ruby %}
function foo({x,y=5}){
    console.log(x,y);
}
foo({})//undefined 5 foo()// TypeError: Cannot read property 'x' of undefined
function fetch(url, { body = '', method = 'GET', headers = {} }) {
  console.log(method);
}
fetch('http://example.com')  //报错
fetch('http://example.com'，{})  //get
如果结合函数参数的默认值，就可以省略第二个参数。就出现了双重默认   
function fetch(url, { method = 'GET' } = {}) {
  console.log(method);
}
fetch('http://example.com')//get
// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}
// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]
// x有值，y无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]
// x和y都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]
m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
{% endhighlight %}
#### 3、函数length属性将失真  
#=>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。    
(function (a) {}).length // 1   
(function (a = 5) {}).length // 0   
(function (a, b, c = 5) {}).length // 2      
length属性的含义是，该函数预期传入的参数个数    
如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。  
rest参数同样不能计入length      
(function(...args) {}).length // 0  
(function (a = 0, b, c) {}).length // 0   
(function (a, b = 1, c) {}).length // 1  
#### 4、作用域   
与其他变量的作用域规则是一样的，先是当前函数的作用域，然后才是全局作用域 。   
{% highlight ruby %}
var x = 1;
function f(x, y = x) {
  console.log(y);
}
f(2) // 2
{% endhighlight %}
{% highlight ruby %}
function f(y = x) {
  let x = 2;
  console.log(y);
}
f() // ReferenceError: x is not defined
let x=1;
function foo(x = x) {}   foo()//报错
{% endhighlight %}
{% highlight ruby %}
let x=1;
function f(y = x) {
  let x = 2;
  console.log(y);
}
f() // 1
{% endhighlight %}
{% highlight ruby %}
let foo = 'outer';
function bar(func = x => foo) {
  let foo = 'inner';
  console.log(func()); // outer
}
bar();
函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。这个匿名函数声明时，bar函数的作用域还没有形成，所以匿名函数里面的foo指向外层作用域的foo，输出outer。
//
var x = 1;
function foo(x, y = function() { x = 2; }) {
  var x = 3;
  y();
  console.log(x);
}
foo() // 3
#=>这两个x是不一样的，互相不产生影响，因此最后输出3。如果将var x = 3的var去除，两个x就是一样的，最后输出的就是2。  
var x = 1;
function foo(x, y = function() { x = 2; }) {
  x = 3;
  y();
  console.log(x);
}
foo() // 2
{% endhighlight %}
#### 4、应用
利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。      
参数的默认值不是在定义时执行，而是在运行时执行，（即如果参数已经赋值，默认值中的函数就不会运行）；
可以将参数默认值设为undefined，表明这个参数是可以省略的。   function foo(optional = undefined) { ··· }
#### 5、rest参数

**博客demo地址**： [Jekyll docs][jekyll-docs] for more info on how to get the most out of Jekyll. File all bugs/feature requests at [Jekyll’s GitHub repo][jekyll-gh]. If you have questions, you can ask them on [Jekyll Talk][jekyll-talk].

[jekyll-docs]: http://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/

